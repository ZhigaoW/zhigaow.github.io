<!DOCTYPE html>
<html>
<head>
<title>NETWORK</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script> 

<style>
        h1 {
                letter-spacing: 2px;
                word-spacing: -0.5em;
                text-align:center;
                color: green;
                font-size: xx-large;
        }

        h2 {
                letter-spacing: 2px;
                word-spacing: -0.5em;
                text-align: center;
                color: green;
        }

        
        h3 {
                letter-spacing: 2px;
                word-spacing: -0.5em;
                color: green;
                text-emphasis: true;
        }

        h4 {
                letter-spacing: 2px;
                word-spacing: -0.5em;
                color:blue;
                text-emphasis: true;
        }
        p {
                word-spacing: 0em;
        }
        a {
                letter-spacing: 2px;
                word-spacing: -0.5em;
                text-decoration: none;
                color:darkblue;
                text-emphasis: true;
        }

        table {
                text-align: left;
                border-left: 0px;
                border-right: 0px;
                background:none;
                border-color:dodgerblue;
        }

        table tr {
                border: 0px;
        }

        table td {
                border: 0px;
        }


</style>
</head>
<body>
        <h1>NETWORK</h1>
        <hr/ >

        <h2>LINUX 性能常用工具</h2>

        <h3>参考资料</h3>
        <p>
                <ol>
                        <li>Netflix 高性能架构师 <a href="https://www.brendangregg.com/">Brendan Gregg's Blog</a> </li>
                        <li> <a href="https://www.wangchujiang.com/linux-command/">linux command search</a> </li>
                </ol>
        </p>
        
        <table cellspacing="10" border="2">
                <tr>
                       <td>ipcs</td>
                       <td>uptime</td>
                       <td>iostat</td>
                       <td>sar</td>
                       <td>mpstat</td>
                       <td>pmap</td>
                       <td>nmon</td>
                       <td>glances</td>
                </tr>
                <tr>
                       <td>ftptop </td>
                       <td>powertop </td> 
                       <td>mytop  </td>
                       <td>htop/top/atop </td> 
                       <td>netstat  </td>
                       <td>ethtool  </td>
                       <td>tcpdump  </td>
                       <td>telnet  </td>
                </tr>
                <tr>
                       <td>strace </td>
                       <td>iptraf</td>
                       <td>iftop</td>
                </tr>
        </table>
        

<h2>LINUX 网络原理代码</h2>







<h2>LINUX NETWORK I/O MULTIPLEXING</h2>



<h3>客户端量比较少时 <code>C10K</code></h3>
        
<pre class="prettyprint">
// 每个线程的线程栈预分配的大小为 8M
// 8M x 128 = 1G 
// 1G的内存大概能有128个客户端连接
void *client_routine(void *arg)
{
        int connfd = *(int *)arg;
        char buff[MAXLINE];

        while (1) {
                int n = recv(connfd, buff, MAXLINE, 0);
                if (n > 0) {
                        buff[n] = '\0';
                        printf("recv msg from client: %s\n", buff);
                } else if (n == 0) {
                        close(connfd);
                }
        }
}

int main(int argc, char **argv)
{
        // 创建一个socket，内核初始化socket相关的数据结构，比如接收消息的队列
        listenfd = socket(AF_INET, SOCK_STREAM, 0))

        // 绑定端口号
        ...

        // 
        bind(listenfd, (struct sockaddr *)&severaddr, sizeof(severaddr))

        // https://man7.org/linux/man-pages/man2/listen.2.html
        listen(listenfd, 10)

        while (1) {
                connfd = accept(listenfd, (struct sockaddr *)NULL, NULL)
                pthread_t threapid;
                pthread_create(&threapid, NULL, client_routine, &connfd);
        }

        close(listenfd);
        return 0;
}
</pre>

<h3>select <code>C10K - C1000K</code></h3>

<pre class="prettyprint">
#include <sys/select.h>
fd_set rfds, rset; // read set

FD_ZERO(&rfds);
FD_SET(listenfd, &rfds); // 将其中一位置为1

int max_fd = listenfd;

while (1) {
        rset = rfds;
        // https://man7.org/linux/man-pages/man2/select.2.html
        // rset 需要copy到内核，再copy出来，限制了性能
        int nready = select(max_fd + 1, &rset, NULL, NULL, NULL);

        if (FD_ISSET(listenfd, &rset)) {
                struct sockaddr_in client;
                socklen_t len = sizeof(client);
                if ((connfd = accept(listenfd,
                                        (struct sockaddr *)&client,
                                        &len)) == -1) {
                        printf("accept socket error: %s(errno: %d)\n",
                                strerror(errno), errno);
                        return 0;
                }

                FD_SET(connfd, &rfds);

                if (connfd > max_fd) {
                        max_fd = connfd;
                }

                if (--nready == 0) {
                        continue;
                }
        }

        int i = 0;
        // 0 | 1 | 2 | listenfd | connfd1 | connfd2
        for (i = listenfd + 1; i <= max_fd; i++) {
                if (FD_ISSET(i, &rset)) {
                        // 客户端调用close的时候，返回0
                        n = recv(i, buf, MAXLINE, 0);
                        if (n > 0) {
                                buf[n] = '\0';
                                printf("recv msg from client: %s\n",
                                        buf);
                        } else if (n == 0) {
                                FD_CLR(i, &rfds);
                                close(i);
                        }
                }
        }
}

</pre>

<h3>pool</h3>

<h3>epoll</h3>
<h4><a href="https://man7.org/linux/man-pages/man7/epoll.7.html">EPOLL</a>      I/O 事件通知工厂</h4>

<pre class="prettyprint"> 
#include &ltsys/epoll.h&gt
// The epoll API can be used either as an <strong>edge-triggered</strong> or a
// <strong>level-triggered</strong> interface and scales well to large numbers of
// watched file descriptors.
</pre>

<p>
epoll API的核心概念是<strong>内核空间</strong>的数据结构<strong>epoll instance</strong>，<br/>
在<strong>用户空间</strong>的视角看来，epoll instance 是两个列表的容器。
</p>

<ul>
        <li>
                The interest list : 监控列表 
        </li>
        <li>
                The ready list : I/O ready 列表
        </li>
</ul>

<strong>创建epoll instance</strong>

<pre class="prettyprint">
// epoll_create() creates a new epoll instance.
int epoll_create(int size);
int epoll_create1(int flags);
</pre>

<pre class="prettyprint">
/*
* 可以[op]操作epfd[epoll instance]里的fd[io file descripe]
*/
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</pre>

<pre>
// epoll_event *event 是用来表明fd[io file descripe]的可读取状态
typedef union epoll_data {
        void        *ptr;
        int          fd;
        uint32_t     u32;
        uint64_t     u64;
} epoll_data_t;
 
struct epoll_event {
        uint32_t     events;      /* Epoll events */
        epoll_data_t data;        /* User data variable */
};
</pre>

<pre class="prettyprint">
/*
* 
*/ 
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
</pre>

<h4>EXAMPLE CODE</h4>

<pre class="prettyprint">
#define MAX_EVENTS 10
struct epoll_event ev, events[MAX_EVENTS];
int listen_sock, conn_sock, nfds, epollfd;

/* Code to set up listening socket, 'listen_sock',
        (socket(), bind(), listen()) omitted. */

epollfd = epoll_create1(0);
if (epollfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
}

ev.events = EPOLLIN;
ev.data.fd = listen_sock;
if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {
        perror("epoll_ctl: listen_sock");
        exit(EXIT_FAILURE);
}

for (;;) {
        nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);
        if (nfds == -1) {
        perror("epoll_wait");
        exit(EXIT_FAILURE);
        }

        for (n = 0; n < nfds; ++n) {
        if (events[n].data.fd == listen_sock) {
                conn_sock = accept(listen_sock,
                                (struct sockaddr *) &addr, &addrlen);
                if (conn_sock == -1) {
                perror("accept");
                exit(EXIT_FAILURE);
                }
                setnonblocking(conn_sock);
                ev.events = EPOLLIN | EPOLLET;
                ev.data.fd = conn_sock;
                if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,
                        &ev) == -1) {
                perror("epoll_ctl: conn_sock");
                exit(EXIT_FAILURE);
                }
        } else {
                do_use_fd(events[n].data.fd);
        }
        }
}
</pre>



<h2> 服务器Reactor与Proactor </h2>










        <!-- 代码
        <pre class="prettyprint">
                
        </pre>
        -->

</body>
</html>
