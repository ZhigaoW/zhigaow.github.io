<!doctype html>
<html>

<head>
        <meta charset='UTF-8'>
        <meta name='viewport' content='width=device-width initial-scale=1'>
        <!--
<link rel="stylesheet" href="../wzg.css">
-->
        <link rel="stylesheet" href="../wzg.css">
        <title>linux-network</title>
</head>

<body>
        <h1 id='linux-network'>LINUX NETWORK</h1>
        <h2 id='性能常用工具'>性能常用工具</h2>
        <h3 id='参考资料'>参考资料</h3>
        <ol start=''>
                <li><a href='https://www.brendangregg.com/'>Netflix 高性能架构师 Brendan Gregg&#39;s Blog</a></li>
                <li><a href='https://wangchujiang.com/linux-command/'>linux command search</a></li>

        </ol>
        <hr />
        <figure>
                <table>
                        <thead>
                                <tr>
                                        <th>&nbsp;</th>
                                        <th>&nbsp;</th>
                                        <th>&nbsp;</th>
                                        <th>&nbsp;</th>
                                        <th>&nbsp;</th>
                                        <th>&nbsp;</th>
                                        <th>&nbsp;</th>
                                        <th>&nbsp;</th>
                                </tr>
                        </thead>
                        <tbody>
                                <tr>
                                        <td>ipcs</td>
                                        <td>uptime</td>
                                        <td>iostat</td>
                                        <td>sar</td>
                                        <td>mpstat</td>
                                        <td>pmap</td>
                                        <td>nmon</td>
                                        <td>glances</td>
                                </tr>
                                <tr>
                                        <td>ftptop</td>
                                        <td>powertop</td>
                                        <td>mytop</td>
                                        <td>htop/top/atop</td>
                                        <td>netstat</td>
                                        <td>ethtool</td>
                                        <td>tcpdump</td>
                                        <td>telnet</td>
                                </tr>
                                <tr>
                                        <td>strace</td>
                                        <td>iptraf</td>
                                        <td>iftop</td>
                                        <td>&nbsp;</td>
                                        <td>&nbsp;</td>
                                        <td>&nbsp;</td>
                                        <td>&nbsp;</td>
                                        <td>&nbsp;</td>
                                </tr>
                        </tbody>
                </table>
        </figure>
        <h2 id='网络原理代码'>网络原理代码</h2>
        <h2 id='socket'>SOCKET</h2>
        <p><img src="./socket.png" referrerpolicy="no-referrer"></p>
        <ol start=''>
                <li><a href='https://stackoverflow.com/questions/1790750/what-is-the-difference-between-read-and-recv-and-between-send-and-write'>What
                                is the Difference Between read() and recv() , and Between send() and write()?</a></li>
                <li><a href='https://stackoverflow.com/questions/34073871/socket-programming-whats-the-difference-between-listen-and-accept'>Socket
                                programming - What&#39;s the difference between listen() and accept()?</a></li>

        </ol>
        <p>&nbsp;</p>
        <pre><code class='language-c' lang='c'>#include &lt; sys/socket.h &gt;
listenfd = int socket(int domain, int type, int protocol);
</code></pre>
        <ul>
                <li>domain : 选择网络层协议 可以选择IPV6或者IPV4等</li>
                <li>type : 选择传输层协议 可以选择TCP或UPD等</li>
                <li>protocol : 具体的PROCOTOL 0值为默认</li>
                <li>return : 成功返回一个socket的文件描述符 失败返回-1</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt; sys/socket.h &gt;
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>
        <ul>
                <li>bind的作用 : 绑定具体的地址，但是一般把这一步叫命名socket.</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt; sys/socket.h &gt;
int listen(int sockfd, int backlog);
</code></pre>
        <ul>
                <li>backlog : 全联接的数量</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include 
int accept(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict addrlen);
</code></pre>
        <p>&nbsp;</p>
        <h3 id='客户端较少时c10k'>客户端较少时C10k </h3>
        <pre><code class='language-c' lang='c'>// 每个线程的线程栈预分配的大小为 8M
// 8M x 128 = 1G 
// 1G的内存大概能有128个客户端连接
void *client_routine(void *arg)
{
        int connfd = *(int *)arg;
        char buff[MAXLINE];

        while (1) {
                int n = recv(connfd, buff, MAXLINE, 0);
                if (n &gt; 0) {
                        buff[n] = &#39;\0&#39;;
                        printf(&quot;recv msg from client: %s\n&quot;, buff);
                } else if (n == 0) {
                        close(connfd);
                }
        }
}

int main(int argc, char **argv)
{
        // 创建一个socket，内核初始化socket相关的数据结构，比如接收消息的队列
        listenfd = socket(AF_INET, SOCK_STREAM, 0))

        // 绑定端口号
        ...

        // 
        bind(listenfd, (struct sockaddr *)&amp;severaddr, sizeof(severaddr))

        // https://man7.org/linux/man-pages/man2/listen.2.html
        listen(listenfd, 10)

        while (1) {
                connfd = accept(listenfd, (struct sockaddr *)NULL, NULL)
                pthread_t threapid;
                pthread_create(&amp;threapid, NULL, client_routine, &amp;connfd);
        }

        close(listenfd);
        return 0;
}
</code></pre>
        <p>&nbsp;</p>
        <p>&nbsp;</p>
        <h2 id='io-multiplexing'>I/O MULTIPLEXING</h2>
        <h3 id='epoll'>Epoll</h3>
        <p><a href='https://stackoverflow.com/questions/2794535/linux-and-i-o-completion-ports'>Linux and I/O completion
                        ports?</a></p>
        <pre><code class='language-c' lang='c'>#include &lt;sys/epoll.h&gt;
// The epoll API can be used either as an edge-triggered or a
// level-triggered interface and scales well to large numbers of
// watched file descriptors.
</code></pre>
        <p>epoll API的核心概念是<strong>内核空间</strong>的数据结构<strong>epoll instance</strong>，
                在<strong>用户空间</strong>的视角看来，epoll instance 是两个列表的容器。</p>
        <ul>
                <li>The interest list : 监控列表</li>
                <li>The ready list : I/O ready 列表</li>

        </ul>
        <p><strong>创建epoll instance</strong></p>
        <pre><code class='language-c' lang='c'>// epoll_create() creates a new epoll instance.
int epoll_create(int size);
int epoll_create1(int flags);
/*
* 可以[op]操作epfd[epoll instance]里的fd[io file descripe]
*/
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
// epoll_event *event 是用来表明fd[io file descripe]的可读取状态
typedef union epoll_data {
        void        *ptr;
        int          fd;
        uint32_t     u32;
        uint64_t     u64;
} epoll_data_t;
 
struct epoll_event {
        uint32_t     events;      /* Epoll events */
        epoll_data_t data;        /* User data variable */
};
/*
* 
*/ 
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
</code></pre>
        <h4 id='example-code'>EXAMPLE CODE</h4>
        <pre><code class='language-c' lang='c'>#define MAX_EVENTS 10
struct epoll_event ev, events[MAX_EVENTS];
int listen_sock, conn_sock, nfds, epollfd;

/* Code to set up listening socket, &#39;listen_sock&#39;,
        (socket(), bind(), listen()) omitted. */

epollfd = epoll_create1(0);
if (epollfd == -1) {
        perror(&quot;epoll_create1&quot;);
        exit(EXIT_FAILURE);
}

ev.events = EPOLLIN;
ev.data.fd = listen_sock;
if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == -1) {
        perror(&quot;epoll_ctl: listen_sock&quot;);
        exit(EXIT_FAILURE);
}

for (;;) {
        nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);
        if (nfds == -1) {
        perror(&quot;epoll_wait&quot;);
        exit(EXIT_FAILURE);
        }

        for (n = 0; n &lt; nfds; ++n) {
        if (events[n].data.fd == listen_sock) {
                conn_sock = accept(listen_sock,
                                (struct sockaddr *) &amp;addr, &amp;addrlen);
                if (conn_sock == -1) {
                perror(&quot;accept&quot;);
                exit(EXIT_FAILURE);
                }
                setnonblocking(conn_sock);
                ev.events = EPOLLIN | EPOLLET;
                ev.data.fd = conn_sock;
                if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,
                        &amp;ev) == -1) {
                perror(&quot;epoll_ctl: conn_sock&quot;);
                exit(EXIT_FAILURE);
                }
        } else {
                do_use_fd(events[n].data.fd);
        }
        }
}
</code></pre>
        <h2 id='服务器reactor与proactor'>服务器Reactor与Proactor</h2>
        <p>&nbsp;</p>
</body>

</html>
